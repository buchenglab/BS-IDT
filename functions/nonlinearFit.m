function [NAy_fit, NAx_fit] = nonlinearFit(NAx, NAy, BR, fDL, Sorted_Pos, lambda)
%% nonlinearFit Function
%
% Purpose: This function applies a nonlinear 2D fitting algorithm to the 2D
%          IDT illumination angle grid. The assumption of this algorithm is
%          that the IDT LED array has rigidly spaced LEDs and fits the
%          calibrated LED positions from the code in "Efficient
%          illumination angle self-calibration in Fourier ptychography" by
%          Eckert et al. to reflect this grid-like design. 
%
% Inputs:  BR - scalar value denoting LED ring radius
%          fDL - scalar value denoting distance between the LED ring and
%               sample.
%          NAx - vector containing calibrated illumination spatial 
%                frequencies along x.
%          NAy - cector containing calibrated illumination spatial
%                frequencies along y.
%          lambda - scalar value denoting imaging wavelength (um)
%          Sorted_Pos - 2 x N matrix denoting the approximate LED positions
%                       based on their x,y positions along a unit circle.
%                       This is typically generated by assuming a fixed
%                       angle step size and generating the cartesian
%                       coordinate positions for each illumination on the
%                       unit circle. 
%
% Outputs:  NAy_fit - vector containing corrected vertical spatial
%                     frequencies.
%           NAx_fit - vector containing corrected horizontal spatial
%                     frequencies.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Define fitting function handle
F=@(Q,R)...
   ((((BR*cos(pi/180*Q(1)).*R(:,1)-BR*sin(pi/180*Q(1)).*R(:,2)+Q(2))./ ...
sqrt(((BR*cos(pi/180*Q(1)).*R(:,1)-BR*sin(pi/180*Q(1)).*R(:,2)+Q(2))).^2+ ...
      (BR*sin(pi/180*Q(1)).*R(:,1)+BR*cos(pi/180*Q(1)).*R(:,2)+Q(3)).^2+Q(4).^2)./lambda)-R(:,3)).^2+...
    (((BR*sin(pi/180*Q(1)).*R(:,1)+BR*cos(pi/180*Q(1)).*R(:,2)+Q(3))./ ...
sqrt(((BR*cos(pi/180*Q(1)).*R(:,1)-BR*sin(pi/180*Q(1)).*R(:,2)+Q(2))).^2+ ...
      (BR*sin(pi/180*Q(1)).*R(:,1)+BR*cos(pi/180*Q(1)).*R(:,2)+Q(3)).^2+Q(4).^2)./lambda)-R(:,4)).^2);       

%% Variable Initialization
Q0 = [0, 0, 0, fDL];  % Initialize correction term. Has the form
%                       [angle correction factor, LED x correction, ...
%                        LED y correction, LED-sample distance guess]

%% Apply fitting algorithm
% Generate matrix containing approximate, calibrated illumination positions
R = [Sorted_Pos(1,:)',Sorted_Pos(2,:)',NAx',NAy'];

% Apply nonlinear fit
[Q] = nlinfit(R,zeros(size(R,1),1),F,Q0);

%% Extract updated illumination spatial frequencies
NAy_fit = ((BR*cos(pi/180*Q(1)).*R(:,1)-BR*sin(pi/180*Q(1)).*R(:,2)+Q(2))./ ...
       sqrt((BR*cos(pi/180*Q(1)).*R(:,1)-BR*sin(pi/180*Q(1)).*R(:,2)+Q(2)).^2+ ...
            (BR*sin(pi/180*Q(1)).*R(:,1)+BR*cos(pi/180*Q(1)).*R(:,2)+Q(3)).^2+Q(4).^2)./lambda)';

NAx_fit = ((BR*sin(pi/180*Q(1)).*R(:,1)+BR*cos(pi/180*Q(1)).*R(:,2)+Q(3))./ ...
       sqrt((BR*cos(pi/180*Q(1)).*R(:,1)-BR*sin(pi/180*Q(1)).*R(:,2)+Q(2)).^2+ ...
            (BR*sin(pi/180*Q(1)).*R(:,1)+BR*cos(pi/180*Q(1)).*R(:,2)+Q(3)).^2+Q(4).^2)./lambda)';

end  % End of Function